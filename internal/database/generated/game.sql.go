// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: game.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGame = `-- name: CreateGame :one
INSERT INTO games (
    club_id,
    left_odd_player_name,
    left_even_player_name,
    right_odd_player_name,
    right_even_player_name,
    game_type,
    serving_side,
    created_at
) VALUES (
    $1::uuid,
    $2::text,
    $3::text,
    $4::text,
    $5::text,
    $6::text,
    $7::text,
    $8
) RETURNING id, club_id, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, game_type, serving_side, is_ended, created_at, updated_at
`

type CreateGameParams struct {
	ClubID              pgtype.UUID
	LeftOddPlayerName   string
	LeftEvenPlayerName  string
	RightOddPlayerName  string
	RightEvenPlayerName string
	GameType            string
	ServingSide         string
	CreatedAt           pgtype.Timestamp
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame,
		arg.ClubID,
		arg.LeftOddPlayerName,
		arg.LeftEvenPlayerName,
		arg.RightOddPlayerName,
		arg.RightEvenPlayerName,
		arg.GameType,
		arg.ServingSide,
		arg.CreatedAt,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.ClubID,
		&i.LeftOddPlayerName,
		&i.LeftEvenPlayerName,
		&i.RightOddPlayerName,
		&i.RightEvenPlayerName,
		&i.GameType,
		&i.ServingSide,
		&i.IsEnded,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGameStatistic = `-- name: CreateGameStatistic :one
INSERT INTO game_statistics(
    game_id,
    total_game_time_seconds, 
    right_consecutive_points,
    left_consecutive_points,
    left_longest_point_seconds,
    left_shortest_point_seconds,
    right_longest_point_seconds,
    right_shortest_point_seconds,
    average_time_per_point_seconds,
    right_average_time_per_point_seconds,
    left_average_time_per_point_seconds
) VALUES (
    $1::uuid,
    $2::int,
    $3::int,
    $4::int,
    $5::int,
    $6::int,
    $7::int,
    $8::int,
    $9::int,
    $10::int,
    $11::int
) RETURNING id, game_id, total_game_time_seconds, right_consecutive_points, left_consecutive_points, left_longest_point_seconds, left_shortest_point_seconds, right_longest_point_seconds, right_shortest_point_seconds, average_time_per_point_seconds, left_average_time_per_point_seconds, right_average_time_per_point_seconds, created_at, updated_at
`

type CreateGameStatisticParams struct {
	GameID                          pgtype.UUID
	TotalGameTimeSeconds            int32
	RightConsecutivePoints          int32
	LeftConsecutivePoints           int32
	LeftLongestPointSeconds         int32
	LeftShortestPointSeconds        int32
	RightLongestPointSeconds        int32
	RightShortestPointSeconds       int32
	AverageTimePerPointSeconds      int32
	RightAverageTimePerPointSeconds int32
	LeftAverageTimePerPointSeconds  int32
}

func (q *Queries) CreateGameStatistic(ctx context.Context, arg CreateGameStatisticParams) (GameStatistic, error) {
	row := q.db.QueryRow(ctx, createGameStatistic,
		arg.GameID,
		arg.TotalGameTimeSeconds,
		arg.RightConsecutivePoints,
		arg.LeftConsecutivePoints,
		arg.LeftLongestPointSeconds,
		arg.LeftShortestPointSeconds,
		arg.RightLongestPointSeconds,
		arg.RightShortestPointSeconds,
		arg.AverageTimePerPointSeconds,
		arg.RightAverageTimePerPointSeconds,
		arg.LeftAverageTimePerPointSeconds,
	)
	var i GameStatistic
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.TotalGameTimeSeconds,
		&i.RightConsecutivePoints,
		&i.LeftConsecutivePoints,
		&i.LeftLongestPointSeconds,
		&i.LeftShortestPointSeconds,
		&i.RightLongestPointSeconds,
		&i.RightShortestPointSeconds,
		&i.AverageTimePerPointSeconds,
		&i.LeftAverageTimePerPointSeconds,
		&i.RightAverageTimePerPointSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGameStep = `-- name: CreateGameStep :one
INSERT INTO game_steps (
    game_id,
    team_left_score,
    team_right_score,
    score_at,
    step_num,
    current_server,
    left_odd_player_name,
    left_even_player_name,
    right_odd_player_name,
    right_even_player_name,
    sync_id,
    is_paused
) VALUES (
    $1::uuid,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7::text,                         
    $8::text,
    $9::text,
    $10::text,
    $11,
    $12::int
) ON CONFLICT (game_id, step_num) DO NOTHING 
RETURNING id, game_id, team_left_score, team_right_score, score_at, step_num, current_server, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, is_paused, sync_id, created_at, updated_at
`

type CreateGameStepParams struct {
	GameID              pgtype.UUID
	TeamLeftScore       int32
	TeamRightScore      int32
	ScoreAt             pgtype.Timestamp
	StepNum             int32
	CurrentServer       string
	LeftOddPlayerName   string
	LeftEvenPlayerName  string
	RightOddPlayerName  string
	RightEvenPlayerName string
	SyncID              string
	IsPaused            int32
}

func (q *Queries) CreateGameStep(ctx context.Context, arg CreateGameStepParams) (GameStep, error) {
	row := q.db.QueryRow(ctx, createGameStep,
		arg.GameID,
		arg.TeamLeftScore,
		arg.TeamRightScore,
		arg.ScoreAt,
		arg.StepNum,
		arg.CurrentServer,
		arg.LeftOddPlayerName,
		arg.LeftEvenPlayerName,
		arg.RightOddPlayerName,
		arg.RightEvenPlayerName,
		arg.SyncID,
		arg.IsPaused,
	)
	var i GameStep
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.TeamLeftScore,
		&i.TeamRightScore,
		&i.ScoreAt,
		&i.StepNum,
		&i.CurrentServer,
		&i.LeftOddPlayerName,
		&i.LeftEvenPlayerName,
		&i.RightOddPlayerName,
		&i.RightEvenPlayerName,
		&i.IsPaused,
		&i.SyncID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrUpdateGameHistory = `-- name: CreateOrUpdateGameHistory :one
INSERT INTO game_histories(
    user_id,
    game_id,
    player_position,
    game_started_at,
    game_won_by,
    total_points,
    points_won,
    points_lost,
    average_time_per_point_seconds,
    average_time_per_point_won_seconds,
    average_time_per_point_lost_seconds,
    longest_rally_seconds,
    longest_rally_is_won,
    shortest_rally_seconds,
    shortest_rally_is_won,
    is_game_won,
    total_game_time_seconds
) VALUES (
    $1::uuid,
    $2::uuid,
    $3::text,
    $4,
    $5::text,
    $6::int,
    $7::int,
    $8::int,
    $9::int,
    $10::int,
    $11::int,
    $12::int,
    $13::int,
    $14::int,
    $15::int,
    $16::int,
    $17::int
) 
ON CONFLICT (user_id,game_id) DO UPDATE
    SET 
    player_position = EXCLUDED.player_position,
    game_started_at = EXCLUDED.game_started_at,
    game_won_by = EXCLUDED.game_won_by,
    total_points = EXCLUDED.total_points,
    points_won = EXCLUDED.points_won,
    points_lost = EXCLUDED.points_lost,
    average_time_per_point_seconds = EXCLUDED.average_time_per_point_seconds,
    average_time_per_point_won_seconds = EXCLUDED.average_time_per_point_won_seconds,
    average_time_per_point_lost_seconds = EXCLUDED.average_time_per_point_lost_seconds,
    longest_rally_seconds = EXCLUDED.longest_rally_seconds,
    longest_rally_is_won = EXCLUDED.longest_rally_is_won,
    shortest_rally_seconds = EXCLUDED.shortest_rally_seconds,
    shortest_rally_is_won = EXCLUDED.shortest_rally_is_won,
    is_game_won = EXCLUDED.is_game_won,
    total_game_time_seconds = EXCLUDED.total_game_time_seconds,
    updated_at = now()
RETURNING id, user_id, game_id, player_position, is_game_won, game_started_at, game_won_by, total_points, points_won, points_lost, average_time_per_point_seconds, average_time_per_point_won_seconds, average_time_per_point_lost_seconds, longest_rally_seconds, longest_rally_is_won, shortest_rally_seconds, shortest_rally_is_won, total_game_time_seconds, created_at, updated_at
`

type CreateOrUpdateGameHistoryParams struct {
	UserID                         pgtype.UUID
	GameID                         pgtype.UUID
	PlayerPosition                 string
	GameStartedAt                  pgtype.Timestamp
	GameWonBy                      string
	TotalPoints                    int32
	PointsWon                      int32
	PointsLost                     int32
	AverageTimePerPointSeconds     int32
	AverageTimePerPointWonSeconds  int32
	AverageTimePerPointLostSeconds int32
	LongestRallySeconds            int32
	LongestRallyIsWon              int32
	ShortestRallySeconds           int32
	ShortestRallyIsWon             int32
	IsGameWon                      int32
	TotalGameTimeSeconds           int32
}

func (q *Queries) CreateOrUpdateGameHistory(ctx context.Context, arg CreateOrUpdateGameHistoryParams) (GameHistory, error) {
	row := q.db.QueryRow(ctx, createOrUpdateGameHistory,
		arg.UserID,
		arg.GameID,
		arg.PlayerPosition,
		arg.GameStartedAt,
		arg.GameWonBy,
		arg.TotalPoints,
		arg.PointsWon,
		arg.PointsLost,
		arg.AverageTimePerPointSeconds,
		arg.AverageTimePerPointWonSeconds,
		arg.AverageTimePerPointLostSeconds,
		arg.LongestRallySeconds,
		arg.LongestRallyIsWon,
		arg.ShortestRallySeconds,
		arg.ShortestRallyIsWon,
		arg.IsGameWon,
		arg.TotalGameTimeSeconds,
	)
	var i GameHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GameID,
		&i.PlayerPosition,
		&i.IsGameWon,
		&i.GameStartedAt,
		&i.GameWonBy,
		&i.TotalPoints,
		&i.PointsWon,
		&i.PointsLost,
		&i.AverageTimePerPointSeconds,
		&i.AverageTimePerPointWonSeconds,
		&i.AverageTimePerPointLostSeconds,
		&i.LongestRallySeconds,
		&i.LongestRallyIsWon,
		&i.ShortestRallySeconds,
		&i.ShortestRallyIsWon,
		&i.TotalGameTimeSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrUpdateGameRecentStatistic = `-- name: CreateOrUpdateGameRecentStatistic :one
INSERT INTO game_recent_statistics(
    user_id,
    game_count,
    wins,
    losses,
    total_points,
    points_won,
    average_time_per_point_seconds,
    average_time_per_point_won_seconds,
    average_time_per_point_lost_seconds,
    longest_rally_seconds,
    longest_rally_is_won,
    shortest_rally_seconds,
    shortest_rally_is_won,
    average_time_per_game_seconds,
    needs_regenerating
) VALUES (
    $1::uuid,
    $2::int,
    $3::int,
    $4::int,
    $5::int,
    $6::int,
    $7::int,
    $8::int,
    $9::int,
    $10::int,
    $11::int,
    $12::int,
    $13::int,
    $14::int,
    $15::int
) 
ON CONFLICT (user_id) DO UPDATE
    SET 
    game_count = EXCLUDED.game_count,
    wins = EXCLUDED.wins,
    losses = EXCLUDED.losses,
    total_points = EXCLUDED.total_points,
    points_won = EXCLUDED.points_won,
    average_time_per_point_seconds = EXCLUDED.average_time_per_point_seconds, 
    average_time_per_point_won_seconds = EXCLUDED.average_time_per_point_won_seconds,
    average_time_per_point_lost_seconds = EXCLUDED.average_time_per_point_lost_seconds,
    longest_rally_seconds = EXCLUDED.longest_rally_seconds,
    longest_rally_is_won = EXCLUDED.longest_rally_is_won,
    shortest_rally_seconds = EXCLUDED.shortest_rally_seconds,
    shortest_rally_is_won = EXCLUDED.shortest_rally_is_won,
    average_time_per_game_seconds = EXCLUDED.average_time_per_game_seconds,
    needs_regenerating = EXCLUDED.needs_regenerating,
    updated_at = now()
RETURNING id, user_id, game_count, wins, losses, total_points, points_won, average_time_per_point_seconds, average_time_per_point_won_seconds, average_time_per_point_lost_seconds, longest_rally_seconds, longest_rally_is_won, shortest_rally_seconds, shortest_rally_is_won, average_time_per_game_seconds, needs_regenerating, created_at, updated_at
`

type CreateOrUpdateGameRecentStatisticParams struct {
	UserID                         pgtype.UUID
	GameCount                      int32
	Wins                           int32
	Losses                         int32
	TotalPoints                    int32
	PointsWon                      int32
	AverageTimePerPointSeconds     int32
	AverageTimePerPointWonSeconds  int32
	AverageTimePerPointLostSeconds int32
	LongestRallySeconds            int32
	LongestRallyIsWon              int32
	ShortestRallySeconds           int32
	ShortestRallyIsWon             int32
	AverageTimePerGameSeconds      int32
	NeedsRegenerating              int32
}

func (q *Queries) CreateOrUpdateGameRecentStatistic(ctx context.Context, arg CreateOrUpdateGameRecentStatisticParams) (GameRecentStatistic, error) {
	row := q.db.QueryRow(ctx, createOrUpdateGameRecentStatistic,
		arg.UserID,
		arg.GameCount,
		arg.Wins,
		arg.Losses,
		arg.TotalPoints,
		arg.PointsWon,
		arg.AverageTimePerPointSeconds,
		arg.AverageTimePerPointWonSeconds,
		arg.AverageTimePerPointLostSeconds,
		arg.LongestRallySeconds,
		arg.LongestRallyIsWon,
		arg.ShortestRallySeconds,
		arg.ShortestRallyIsWon,
		arg.AverageTimePerGameSeconds,
		arg.NeedsRegenerating,
	)
	var i GameRecentStatistic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GameCount,
		&i.Wins,
		&i.Losses,
		&i.TotalPoints,
		&i.PointsWon,
		&i.AverageTimePerPointSeconds,
		&i.AverageTimePerPointWonSeconds,
		&i.AverageTimePerPointLostSeconds,
		&i.LongestRallySeconds,
		&i.LongestRallyIsWon,
		&i.ShortestRallySeconds,
		&i.ShortestRallyIsWon,
		&i.AverageTimePerGameSeconds,
		&i.NeedsRegenerating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGameStep = `-- name: DeleteGameStep :exec
DELETE FROM game_steps where id = $1::uuid
`

func (q *Queries) DeleteGameStep(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameStep, id)
	return err
}

const endGame = `-- name: EndGame :exec
UPDATE games SET is_ended = $1 
WHERE id = $2
`

type EndGameParams struct {
	IsEnded bool
	ID      pgtype.UUID
}

func (q *Queries) EndGame(ctx context.Context, arg EndGameParams) error {
	_, err := q.db.Exec(ctx, endGame, arg.IsEnded, arg.ID)
	return err
}

const endGames = `-- name: EndGames :exec
UPDATE games SET is_ended = true WHERE id = ANY($1::uuid[])
`

func (q *Queries) EndGames(ctx context.Context, gameIds []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, endGames, gameIds)
	return err
}

const getAbandonedGames = `-- name: GetAbandonedGames :many
SELECT DISTINCT game_id from game_steps WHERE score_at < NOW() - INTERVAL '5 hours'
`

func (q *Queries) GetAbandonedGames(ctx context.Context) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getAbandonedGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var game_id pgtype.UUID
		if err := rows.Scan(&game_id); err != nil {
			return nil, err
		}
		items = append(items, game_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveGames = `-- name: GetActiveGames :many
SELECT id, club_id, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, game_type, serving_side, is_ended, created_at, updated_at FROM games WHERE club_id = $1::uuid AND is_ended = FALSE ORDER BY created_at DESC limit 10
`

func (q *Queries) GetActiveGames(ctx context.Context, clubID pgtype.UUID) ([]Game, error) {
	rows, err := q.db.Query(ctx, getActiveGames, clubID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.ClubID,
			&i.LeftOddPlayerName,
			&i.LeftEvenPlayerName,
			&i.RightOddPlayerName,
			&i.RightEvenPlayerName,
			&i.GameType,
			&i.ServingSide,
			&i.IsEnded,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClubGames = `-- name: GetClubGames :many
SELECT 
    id, club_id, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, game_type, serving_side, is_ended, created_at, updated_at,
    COUNT(*) OVER() AS total_count 
FROM games 
WHERE 
    club_id = $1
ORDER BY
  CASE WHEN $2::text = 'created_at_asc' THEN g.created_at END ASC,
  CASE WHEN $2::text = 'created_at_desc' THEN g.created_at END DESC
LIMIT $4::int
OFFSET $3::int
`

type GetClubGamesParams struct {
	ClubID            pgtype.UUID
	SortGameCreatedAt string
	OffsetCount       int32
	LimitCount        int32
}

type GetClubGamesRow struct {
	ID                  pgtype.UUID
	ClubID              pgtype.UUID
	LeftOddPlayerName   *string
	LeftEvenPlayerName  string
	RightOddPlayerName  *string
	RightEvenPlayerName string
	GameType            string
	ServingSide         string
	IsEnded             bool
	CreatedAt           pgtype.Timestamp
	UpdatedAt           pgtype.Timestamp
	TotalCount          int64
}

func (q *Queries) GetClubGames(ctx context.Context, arg GetClubGamesParams) ([]GetClubGamesRow, error) {
	rows, err := q.db.Query(ctx, getClubGames,
		arg.ClubID,
		arg.SortGameCreatedAt,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClubGamesRow
	for rows.Next() {
		var i GetClubGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClubID,
			&i.LeftOddPlayerName,
			&i.LeftEvenPlayerName,
			&i.RightOddPlayerName,
			&i.RightEvenPlayerName,
			&i.GameType,
			&i.ServingSide,
			&i.IsEnded,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameHistoryGivenUserIdAndGameId = `-- name: GetGameHistoryGivenUserIdAndGameId :one
SELECT id, user_id, game_id, player_position, is_game_won, game_started_at, game_won_by, total_points, points_won, points_lost, average_time_per_point_seconds, average_time_per_point_won_seconds, average_time_per_point_lost_seconds, longest_rally_seconds, longest_rally_is_won, shortest_rally_seconds, shortest_rally_is_won, total_game_time_seconds, created_at, updated_at FROM game_histories WHERE game_id = $1::uuid AND user_id = $2::uuid limit 1
`

type GetGameHistoryGivenUserIdAndGameIdParams struct {
	GameID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) GetGameHistoryGivenUserIdAndGameId(ctx context.Context, arg GetGameHistoryGivenUserIdAndGameIdParams) (GameHistory, error) {
	row := q.db.QueryRow(ctx, getGameHistoryGivenUserIdAndGameId, arg.GameID, arg.UserID)
	var i GameHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GameID,
		&i.PlayerPosition,
		&i.IsGameWon,
		&i.GameStartedAt,
		&i.GameWonBy,
		&i.TotalPoints,
		&i.PointsWon,
		&i.PointsLost,
		&i.AverageTimePerPointSeconds,
		&i.AverageTimePerPointWonSeconds,
		&i.AverageTimePerPointLostSeconds,
		&i.LongestRallySeconds,
		&i.LongestRallyIsWon,
		&i.ShortestRallySeconds,
		&i.ShortestRallyIsWon,
		&i.TotalGameTimeSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGameRecentStatisticThatNeedsRegeneration = `-- name: GetGameRecentStatisticThatNeedsRegeneration :many
SELECT id, user_id, game_count, wins, losses, total_points, points_won, average_time_per_point_seconds, average_time_per_point_won_seconds, average_time_per_point_lost_seconds, longest_rally_seconds, longest_rally_is_won, shortest_rally_seconds, shortest_rally_is_won, average_time_per_game_seconds, needs_regenerating, created_at, updated_at FROM game_recent_statistics WHERE needs_regenerating = 1 limit 10
`

func (q *Queries) GetGameRecentStatisticThatNeedsRegeneration(ctx context.Context) ([]GameRecentStatistic, error) {
	rows, err := q.db.Query(ctx, getGameRecentStatisticThatNeedsRegeneration)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameRecentStatistic
	for rows.Next() {
		var i GameRecentStatistic
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GameCount,
			&i.Wins,
			&i.Losses,
			&i.TotalPoints,
			&i.PointsWon,
			&i.AverageTimePerPointSeconds,
			&i.AverageTimePerPointWonSeconds,
			&i.AverageTimePerPointLostSeconds,
			&i.LongestRallySeconds,
			&i.LongestRallyIsWon,
			&i.ShortestRallySeconds,
			&i.ShortestRallyIsWon,
			&i.AverageTimePerGameSeconds,
			&i.NeedsRegenerating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameRecentStatisticWithUserId = `-- name: GetGameRecentStatisticWithUserId :one
SELECT id, user_id, game_count, wins, losses, total_points, points_won, average_time_per_point_seconds, average_time_per_point_won_seconds, average_time_per_point_lost_seconds, longest_rally_seconds, longest_rally_is_won, shortest_rally_seconds, shortest_rally_is_won, average_time_per_game_seconds, needs_regenerating, created_at, updated_at FROM game_recent_statistics WHERE user_id = $1::uuid limit 1
`

func (q *Queries) GetGameRecentStatisticWithUserId(ctx context.Context, userID pgtype.UUID) (GameRecentStatistic, error) {
	row := q.db.QueryRow(ctx, getGameRecentStatisticWithUserId, userID)
	var i GameRecentStatistic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GameCount,
		&i.Wins,
		&i.Losses,
		&i.TotalPoints,
		&i.PointsWon,
		&i.AverageTimePerPointSeconds,
		&i.AverageTimePerPointWonSeconds,
		&i.AverageTimePerPointLostSeconds,
		&i.LongestRallySeconds,
		&i.LongestRallyIsWon,
		&i.ShortestRallySeconds,
		&i.ShortestRallyIsWon,
		&i.AverageTimePerGameSeconds,
		&i.NeedsRegenerating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGameStatisticsWithGameID = `-- name: GetGameStatisticsWithGameID :one
SELECT id, game_id, total_game_time_seconds, right_consecutive_points, left_consecutive_points, left_longest_point_seconds, left_shortest_point_seconds, right_longest_point_seconds, right_shortest_point_seconds, average_time_per_point_seconds, left_average_time_per_point_seconds, right_average_time_per_point_seconds, created_at, updated_at FROM game_statistics WHERE game_id = $1::uuid LIMIT 1
`

func (q *Queries) GetGameStatisticsWithGameID(ctx context.Context, gameID pgtype.UUID) (GameStatistic, error) {
	row := q.db.QueryRow(ctx, getGameStatisticsWithGameID, gameID)
	var i GameStatistic
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.TotalGameTimeSeconds,
		&i.RightConsecutivePoints,
		&i.LeftConsecutivePoints,
		&i.LeftLongestPointSeconds,
		&i.LeftShortestPointSeconds,
		&i.RightLongestPointSeconds,
		&i.RightShortestPointSeconds,
		&i.AverageTimePerPointSeconds,
		&i.LeftAverageTimePerPointSeconds,
		&i.RightAverageTimePerPointSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGameStepsGivenGameIds = `-- name: GetGameStepsGivenGameIds :many
SELECT id, game_id, team_left_score, team_right_score, score_at, step_num, current_server, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, is_paused, sync_id, created_at, updated_at from game_steps WHERE game_id = ANY($1::uuid[])
`

func (q *Queries) GetGameStepsGivenGameIds(ctx context.Context, gameIds []pgtype.UUID) ([]GameStep, error) {
	rows, err := q.db.Query(ctx, getGameStepsGivenGameIds, gameIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameStep
	for rows.Next() {
		var i GameStep
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.TeamLeftScore,
			&i.TeamRightScore,
			&i.ScoreAt,
			&i.StepNum,
			&i.CurrentServer,
			&i.LeftOddPlayerName,
			&i.LeftEvenPlayerName,
			&i.RightOddPlayerName,
			&i.RightEvenPlayerName,
			&i.IsPaused,
			&i.SyncID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameStepsWithGameID = `-- name: GetGameStepsWithGameID :many
SELECT id, game_id, team_left_score, team_right_score, score_at, step_num, current_server, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, is_paused, sync_id, created_at, updated_at FROM game_steps WHERE game_id = $1::uuid
ORDER BY step_num ASC
`

func (q *Queries) GetGameStepsWithGameID(ctx context.Context, gameID pgtype.UUID) ([]GameStep, error) {
	rows, err := q.db.Query(ctx, getGameStepsWithGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameStep
	for rows.Next() {
		var i GameStep
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.TeamLeftScore,
			&i.TeamRightScore,
			&i.ScoreAt,
			&i.StepNum,
			&i.CurrentServer,
			&i.LeftOddPlayerName,
			&i.LeftEvenPlayerName,
			&i.RightOddPlayerName,
			&i.RightEvenPlayerName,
			&i.IsPaused,
			&i.SyncID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameWithID = `-- name: GetGameWithID :one
SELECT id, club_id, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, game_type, serving_side, is_ended, created_at, updated_at FROM games WHERE id = $1::uuid limit 1
`

func (q *Queries) GetGameWithID(ctx context.Context, id pgtype.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, getGameWithID, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.ClubID,
		&i.LeftOddPlayerName,
		&i.LeftEvenPlayerName,
		&i.RightOddPlayerName,
		&i.RightEvenPlayerName,
		&i.GameType,
		&i.ServingSide,
		&i.IsEnded,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInstagramFeedCount = `-- name: GetInstagramFeedCount :one
SELECT count(*) AS total from instagram_feeds
`

func (q *Queries) GetInstagramFeedCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getInstagramFeedCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getLatestInstagramFeed = `-- name: GetLatestInstagramFeed :many
SELECT id, media_id, media_type, media_url, permalink, posted_at, created_at, updated_at from instagram_feeds WHERE media_type = 'CAROUSEL_ALBUM' ORDER BY posted_at DESC LIMIT 5
`

func (q *Queries) GetLatestInstagramFeed(ctx context.Context) ([]InstagramFeed, error) {
	rows, err := q.db.Query(ctx, getLatestInstagramFeed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InstagramFeed
	for rows.Next() {
		var i InstagramFeed
		if err := rows.Scan(
			&i.ID,
			&i.MediaID,
			&i.MediaType,
			&i.MediaUrl,
			&i.Permalink,
			&i.PostedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentGameHistories = `-- name: GetMostRecentGameHistories :many
SELECT id, user_id, game_id, player_position, is_game_won, game_started_at, game_won_by, total_points, points_won, points_lost, average_time_per_point_seconds, average_time_per_point_won_seconds, average_time_per_point_lost_seconds, longest_rally_seconds, longest_rally_is_won, shortest_rally_seconds, shortest_rally_is_won, total_game_time_seconds, created_at, updated_at from game_histories WHERE user_id = $1::uuid ORDER BY game_started_at DESC limit 12
`

func (q *Queries) GetMostRecentGameHistories(ctx context.Context, userID pgtype.UUID) ([]GameHistory, error) {
	rows, err := q.db.Query(ctx, getMostRecentGameHistories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameHistory
	for rows.Next() {
		var i GameHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GameID,
			&i.PlayerPosition,
			&i.IsGameWon,
			&i.GameStartedAt,
			&i.GameWonBy,
			&i.TotalPoints,
			&i.PointsWon,
			&i.PointsLost,
			&i.AverageTimePerPointSeconds,
			&i.AverageTimePerPointWonSeconds,
			&i.AverageTimePerPointLostSeconds,
			&i.LongestRallySeconds,
			&i.LongestRallyIsWon,
			&i.ShortestRallySeconds,
			&i.ShortestRallyIsWon,
			&i.TotalGameTimeSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayedGames = `-- name: GetPlayedGames :many
SELECT 
    g.id, g.club_id, g.left_odd_player_name, g.left_even_player_name, g.right_odd_player_name, g.right_even_player_name, g.game_type, g.serving_side, g.is_ended, g.created_at, g.updated_at,
    g.created_at AS start_time,
    gh.id, gh.user_id, gh.game_id, gh.player_position, gh.is_game_won, gh.game_started_at, gh.game_won_by, gh.total_points, gh.points_won, gh.points_lost, gh.average_time_per_point_seconds, gh.average_time_per_point_won_seconds, gh.average_time_per_point_lost_seconds, gh.longest_rally_seconds, gh.longest_rally_is_won, gh.shortest_rally_seconds, gh.shortest_rally_is_won, gh.total_game_time_seconds, gh.created_at, gh.updated_at,
    COUNT(*) OVER() AS total_count
FROM games AS g 
JOIN  
    game_histories AS gh ON g.id = gh.game_id
WHERE 
    gh.user_id = $1::uuid
ORDER BY
  CASE WHEN $2::text = 'is_game_won_asc' THEN gh.is_game_won END ASC,
  CASE WHEN $2::text = 'is_game_won_desc' THEN gh.is_game_won END DESC,
  CASE WHEN $3::text = 'created_at_asc' THEN g.created_at END ASC,
  CASE WHEN $3::text = 'created_at_desc' THEN g.created_at END DESC
LIMIT $5::int
OFFSET $4::int
`

type GetPlayedGamesParams struct {
	UserID            pgtype.UUID
	SortIsGameWon     string
	SortGameCreatedAt string
	OffsetCount       int32
	LimitCount        int32
}

type GetPlayedGamesRow struct {
	ID                             pgtype.UUID
	ClubID                         pgtype.UUID
	LeftOddPlayerName              *string
	LeftEvenPlayerName             string
	RightOddPlayerName             *string
	RightEvenPlayerName            string
	GameType                       string
	ServingSide                    string
	IsEnded                        bool
	CreatedAt                      pgtype.Timestamp
	UpdatedAt                      pgtype.Timestamp
	StartTime                      pgtype.Timestamp
	ID_2                           pgtype.UUID
	UserID                         pgtype.UUID
	GameID                         pgtype.UUID
	PlayerPosition                 string
	IsGameWon                      int32
	GameStartedAt                  pgtype.Timestamp
	GameWonBy                      string
	TotalPoints                    int32
	PointsWon                      int32
	PointsLost                     int32
	AverageTimePerPointSeconds     int32
	AverageTimePerPointWonSeconds  int32
	AverageTimePerPointLostSeconds int32
	LongestRallySeconds            int32
	LongestRallyIsWon              int32
	ShortestRallySeconds           int32
	ShortestRallyIsWon             int32
	TotalGameTimeSeconds           int32
	CreatedAt_2                    pgtype.Timestamp
	UpdatedAt_2                    pgtype.Timestamp
	TotalCount                     int64
}

func (q *Queries) GetPlayedGames(ctx context.Context, arg GetPlayedGamesParams) ([]GetPlayedGamesRow, error) {
	rows, err := q.db.Query(ctx, getPlayedGames,
		arg.UserID,
		arg.SortIsGameWon,
		arg.SortGameCreatedAt,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayedGamesRow
	for rows.Next() {
		var i GetPlayedGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClubID,
			&i.LeftOddPlayerName,
			&i.LeftEvenPlayerName,
			&i.RightOddPlayerName,
			&i.RightEvenPlayerName,
			&i.GameType,
			&i.ServingSide,
			&i.IsEnded,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartTime,
			&i.ID_2,
			&i.UserID,
			&i.GameID,
			&i.PlayerPosition,
			&i.IsGameWon,
			&i.GameStartedAt,
			&i.GameWonBy,
			&i.TotalPoints,
			&i.PointsWon,
			&i.PointsLost,
			&i.AverageTimePerPointSeconds,
			&i.AverageTimePerPointWonSeconds,
			&i.AverageTimePerPointLostSeconds,
			&i.LongestRallySeconds,
			&i.LongestRallyIsWon,
			&i.ShortestRallySeconds,
			&i.ShortestRallyIsWon,
			&i.TotalGameTimeSeconds,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInstagramFeed = `-- name: UpdateInstagramFeed :exec
INSERT INTO instagram_feeds(
    media_id,
    media_type,
    media_url,
    permalink,
    posted_at
) VALUES (
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5
) ON CONFLICT (media_id) DO NOTHING
`

type UpdateInstagramFeedParams struct {
	MediaID   string
	MediaType string
	MediaUrl  string
	Permalink string
	PostedAt  pgtype.Timestamp
}

func (q *Queries) UpdateInstagramFeed(ctx context.Context, arg UpdateInstagramFeedParams) error {
	_, err := q.db.Exec(ctx, updateInstagramFeed,
		arg.MediaID,
		arg.MediaType,
		arg.MediaUrl,
		arg.Permalink,
		arg.PostedAt,
	)
	return err
}
