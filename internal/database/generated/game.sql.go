// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: game.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGame = `-- name: CreateGame :one
INSERT INTO games (
    club_id,
    left_odd_player_name,
    left_even_player_name,
    right_odd_player_name,
    right_even_player_name,
    game_type,
    serving_side
) VALUES (
    $1::uuid,
    $2::text,
    $3::text,
    $4::text,
    $5::text,
    $6::text,
    $7::text
) RETURNING id, club_id, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, game_type, serving_side, is_ended, created_at, updated_at
`

type CreateGameParams struct {
	ClubID              pgtype.UUID
	LeftOddPlayerName   string
	LeftEvenPlayerName  string
	RightOddPlayerName  string
	RightEvenPlayerName string
	GameType            string
	ServingSide         string
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame,
		arg.ClubID,
		arg.LeftOddPlayerName,
		arg.LeftEvenPlayerName,
		arg.RightOddPlayerName,
		arg.RightEvenPlayerName,
		arg.GameType,
		arg.ServingSide,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.ClubID,
		&i.LeftOddPlayerName,
		&i.LeftEvenPlayerName,
		&i.RightOddPlayerName,
		&i.RightEvenPlayerName,
		&i.GameType,
		&i.ServingSide,
		&i.IsEnded,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGameStep = `-- name: CreateGameStep :one
INSERT INTO game_steps (
    game_id,
    team_left_score,
    team_right_score,
    score_at,
    step_num,
    current_server,
    left_odd_player_name,
    left_even_player_name,
    right_odd_player_name,
    right_even_player_name,
    sync_id
) VALUES (
    $1::uuid,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7::text,                         
    $8::text,
    $9::text,
    $10::text,
    $11
) ON CONFLICT (game_id, step_num) DO NOTHING 
RETURNING id, game_id, team_left_score, team_right_score, score_at, step_num, current_server, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, sync_id, created_at, updated_at
`

type CreateGameStepParams struct {
	GameID              pgtype.UUID
	TeamLeftScore       int32
	TeamRightScore      int32
	ScoreAt             pgtype.Timestamp
	StepNum             int32
	CurrentServer       string
	LeftOddPlayerName   string
	LeftEvenPlayerName  string
	RightOddPlayerName  string
	RightEvenPlayerName string
	SyncID              string
}

func (q *Queries) CreateGameStep(ctx context.Context, arg CreateGameStepParams) (GameStep, error) {
	row := q.db.QueryRow(ctx, createGameStep,
		arg.GameID,
		arg.TeamLeftScore,
		arg.TeamRightScore,
		arg.ScoreAt,
		arg.StepNum,
		arg.CurrentServer,
		arg.LeftOddPlayerName,
		arg.LeftEvenPlayerName,
		arg.RightOddPlayerName,
		arg.RightEvenPlayerName,
		arg.SyncID,
	)
	var i GameStep
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.TeamLeftScore,
		&i.TeamRightScore,
		&i.ScoreAt,
		&i.StepNum,
		&i.CurrentServer,
		&i.LeftOddPlayerName,
		&i.LeftEvenPlayerName,
		&i.RightOddPlayerName,
		&i.RightEvenPlayerName,
		&i.SyncID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGameStep = `-- name: DeleteGameStep :exec
DELETE FROM game_steps where id = $1::uuid
`

func (q *Queries) DeleteGameStep(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameStep, id)
	return err
}

const endGame = `-- name: EndGame :exec
UPDATE games SET is_ended = $1 
WHERE id = $2
`

type EndGameParams struct {
	IsEnded bool
	ID      pgtype.UUID
}

func (q *Queries) EndGame(ctx context.Context, arg EndGameParams) error {
	_, err := q.db.Exec(ctx, endGame, arg.IsEnded, arg.ID)
	return err
}

const getGameStepsWithGameID = `-- name: GetGameStepsWithGameID :many
SELECT id, game_id, team_left_score, team_right_score, score_at, step_num, current_server, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, sync_id, created_at, updated_at FROM game_steps WHERE game_id = $1::uuid
ORDER BY step_num ASC
`

func (q *Queries) GetGameStepsWithGameID(ctx context.Context, gameID pgtype.UUID) ([]GameStep, error) {
	rows, err := q.db.Query(ctx, getGameStepsWithGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameStep
	for rows.Next() {
		var i GameStep
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.TeamLeftScore,
			&i.TeamRightScore,
			&i.ScoreAt,
			&i.StepNum,
			&i.CurrentServer,
			&i.LeftOddPlayerName,
			&i.LeftEvenPlayerName,
			&i.RightOddPlayerName,
			&i.RightEvenPlayerName,
			&i.SyncID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameWithID = `-- name: GetGameWithID :one
SELECT id, club_id, left_odd_player_name, left_even_player_name, right_odd_player_name, right_even_player_name, game_type, serving_side, is_ended, created_at, updated_at FROM games WHERE id = $1::uuid limit 1
`

func (q *Queries) GetGameWithID(ctx context.Context, id pgtype.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, getGameWithID, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.ClubID,
		&i.LeftOddPlayerName,
		&i.LeftEvenPlayerName,
		&i.RightOddPlayerName,
		&i.RightEvenPlayerName,
		&i.GameType,
		&i.ServingSide,
		&i.IsEnded,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
